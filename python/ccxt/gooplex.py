# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import NotSupported


class gooplex(Exchange):

    def describe(self):
        return self.deep_extend(super(gooplex, self).describe(), {
            'id': 'gooplex',
            'name': 'Gooplex',
            'countries': ['BR'],  # US
            'certified': False,
            'pro': False,
            'urls': {
                'doc': 'https://www.gooplex.com.br/apidocs/#api-document-description',
                'fees': 'https://gooplex.zendesk.com/hc/pt/articles/360049326131-O-que-s%C3%A3o-taxas-de-negocia%C3%A7%C3%A3o-',
                'logo': 'https://user-images.githubusercontent.com/228850/93481157-a0a2cb00-f8d4-11ea-8608-d56dd916a9ed.jpg',
                'referral': 'https://www.gooplex.com.br/account/signup?ref=H8QQ57WT',
                'www': 'https://www.gooplex.com.br',
                # API
                'api': {
                    'open': 'https://www.gooplex.com.br/open/v1',
                    'signed': 'https://www.gooplex.com.br/open/v1',
                    'api': 'https://api.binance.com/api',
                },
            },
            'api': {
                'open': {              # public
                    'get': [
                        'common/time',
                        'common/symbols',
                    ],
                },
                'signed': {            # private
                    'get': [
                        'orders',
                        'orders/detail',
                        'orders/trades',
                        'account/spot',
                    ],
                    'post': [
                        'orders',
                        'orders/cancel',
                    ],
                },
                'api': {
                    'get': [
                        'v3/depth',
                        'v3/trades',
                        'v3/aggTrades',
                    ],
                },
            },
            'orderlimits': [
                5,
                10,
                20,
                50,
                100,
                500,
            ],
            'sides': {
                'BUY': 0,
                'SELL': 1,
            },
            'types': {
                'LIMIT': 1,
                'MARKET': 2,
                'STOP_LOSS': 3,
                'STOP_LOSS_LIMIT': 4,
                'TAKE_PROFIT': 5,
                'TAKE_PROFIT_LIMIT': 6,
                'LIMIT_MAKER': 7,
            },
            'fees': {
                'trading': {
                    'taker': 0.0022,  # 0.22% trading fee
                    'maker': 0.0022,  # 0.22% trading fee
                },
            },
        })

    def sign(self, path, api='open', method='GET', params={}, headers=None, body=None):
        if not (api in self.urls['api']):
            raise NotSupported(self.id + ' does not have a testnet/sandbox URL for ' + api + ' endpoints')
        url = self.urls['api'][api]
        url += '/' + path
        if api == 'signed':
            self.check_required_credentials()
            headers = {
                'X-MBX-APIKEY': self.apiKey,
            }
            recvWindow = self.safe_integer(self.options, 'recvWindow', 5000)
            query = None
            query = self.urlencode_with_array_repeat(self.extend({
                'timestamp': self.nonce(),
                'recvWindow': recvWindow,
            }, params))
            signature = self.hmac(self.encode(query), self.encode(self.secret))
            query += '&signature=' + signature
            url += '?' + query
        else:
            if method == 'GET':
                if params:
                    url += '?' + self.urlencode(params)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def fetch_time(self, params={}):
        method = 'openGetCommonTime'
        response = getattr(self, method)(params)
        return self.safe_integer(response, 'timestamp')

    def get_fees(self):
        feesKey = 'fees'
        fees = getattr(self, feesKey)
        return self.safe_value(fees, 'trading')

    def convert_symbol(self, market):
        trading_fees = self.get_fees()
        symbol = self.safe_string(market, 'symbol')
        id = symbol.replace('_', '/')
        id2 = symbol.replace('_', '')
        entry = {
            'id': symbol,
            'symbol': id,
            'symbol2': id2,
            'base': self.safe_currency_code(market, 'baseAsset'),
            'quote': self.safe_currency_code(market, 'quoteAsset'),
            'active': True,
            'taker': self.safe_float(trading_fees, 'taker'),
            'maker': self.safe_float(trading_fees, 'maker'),
            'percetage': True,
            'tierBase': False,
            'precision': {
                'price': self.safe_integer(market, 'quotePrecision'),
                'amount': self.safe_integer(market, 'basePrecision'),
                'cost': self.safe_integer(market, 'basePrecision'),
            },
            'limits': {
                'amount': {
                    'min': None,
                    'max': None,
                },
                'price': {
                    'min': None,
                    'max': None,
                },
                'cost': {
                    'min': None,
                    'max': None,
                },
            },
            'info': market,
        }
        return entry

    def fetch_markets(self, params={}):
        method = 'openGetCommonSymbols'
        response = getattr(self, method)(params)
        data = self.safe_value(response, 'data')
        markets = self.safe_value(data, 'list')
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            entry = self.convert_symbol(market)
            result.append(entry)
        return result

    def fetch_order_book(self, symbol, limit=None, params={}):
        method = 'apiGetV3Depth'
        self.load_markets()
        request = {
            'symbol': self.markets[symbol]['symbol2'],
        }
        if limit is not None:
            request['limit'] = limit
        response = getattr(self, method)(self.extend(request, params))
        return response

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired('fetchOrders requires a symbol argument')
        method = 'signedGetOrders'
        self.load_markets()
        request = {
            'symbol': self.markets[symbol]['id'],
        }
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit
        response = getattr(self, method)(self.extend(request, params))
        return response

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        requestSide = None
        requestType = None
        if side in self.sides:
            requestSide = self.sides[side]
        else:
            raise NotSupported('Side ' + side + ' not supported')
        if type in self.types:
            requestType = self.types[type]
        else:
            raise NotSupported('Type ' + type + ' not supported.')
        method = 'signedPostOrders'
        self.load_markets()
        request = {
            'symbol': self.markets[symbol]['id'],
            'side': requestSide,
            'type': requestType,
            'quantity': amount,
        }
        if price is not None:
            request['price'] = price
        response = getattr(self, method)(self.extend(request, params))
        return response

    def fetch_order(self, id, symbol=None, params={}):
        method = 'signedGetOrdersDetail'
        request = {
            'orderId': id,
        }
        response = getattr(self, method)(self.extend(request, params))
        return response

    def cancel_order(self, id, symbol=None, params={}):
        method = 'signedPostOrdersCancel'
        request = {
            'orderId': id,
        }
        response = getattr(self, method)(self.extend(request, params))
        return response

    def fetch_balance(self, params={}):
        method = 'signedGetAccountSpot'
        response = getattr(self, method)(params)
        return response

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        method = 'apiGetV3Trades'
        self.load_markets()
        request = {
            'symbol': self.markets[symbol]['symbol2'],
        }
        if since is not None:
            request['fromId'] = since
        if limit is not None:
            request['limit'] = limit
        response = getattr(self, method)(self.extend(request, params))
        return response

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired('fetchOrders requires a symbol argument')
        method = 'signedGetOrdersTrades'
        self.load_markets()
        request = {
            'symbol': self.markets[symbol]['id'],
        }
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit
        response = getattr(self, method)(self.extend(request, params))
        return response

    def parse_l2(self, entry):
        return {
            'tradeId': self.safe_integer(entry, 'a'),
            'price': self.safe_float(entry, 'p'),
            'quantity': self.safe_float(entry, 'q'),
            'firstTradeId': self.safe_integer(entry, 'f'),
            'lastTradeId': self.safe_integer(entry, 'l'),
            'timestamp': self.safe_timestamp(entry, 'T'),
            'maker': self.safe_value(entry, 'm'),
            'bestPriceMatch': self.safe_value(entry, 'M'),
        }

    def fetch_l2_order_book(self, symbol, limit=None, params={}):
        method = 'apiGetV3AggTrades'
        self.load_markets()
        request = {
            'symbol': self.markets[symbol]['symbol2'],
        }
        if limit is not None:
            request['limit'] = limit
        response = getattr(self, method)(self.extend(request, params))
        result = []
        for i in range(0, len(response)):
            result.append(self.parse_l2(response[i]))
        return result
