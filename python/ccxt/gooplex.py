# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import NotSupported


class gooplex(Exchange):

    def describe(self):
        return self.deep_extend(super(gooplex, self).describe(), {
            'id': 'gooplex',
            'name': 'Gooplex',
            'countries': ['BR'],  # US
            'certified': False,
            'pro': False,
            'urls': {
                'doc': 'https://www.gooplex.com.br/apidocs/#api-document-description',
                'fees': 'https://gooplex.zendesk.com/hc/pt/articles/360049326131-O-que-s%C3%A3o-taxas-de-negocia%C3%A7%C3%A3o-',
                'logo': 'https://user-images.githubusercontent.com/228850/93481157-a0a2cb00-f8d4-11ea-8608-d56dd916a9ed.jpg',
                'referral': 'https://www.gooplex.com.br/account/signup?ref=H8QQ57WT',
                'www': 'https://www.gooplex.com.br',
                # API
                'api': {
                    'open': 'https://www.gooplex.com.br/open/v1',
                    'signed': 'https://www.gooplex.com.br/open/v1',
                    'api': 'https://api.binance.com/api',
                },
            },
            'api': {
                'open': {              # public
                    'get': [
                        'common/time',
                        'common/symbols',
                    ],
                },
                'signed': {            # private
                    'get': [
                        'orders',
                        'orders/detail',
                        'orders/trades',
                        'account/spot',
                    ],
                    'post': [
                        'orders',
                        'orders/cancel',
                    ],
                },
                'api': {
                    'get': [
                        'v3/depth',
                        'v3/trades',
                        'v3/aggTrades',
                    ],
                },
            },
            'orderlimits': [
                5,
                10,
                20,
                50,
                100,
                500,
            ],
            'sides': {
                'BUY': 0,
                'SELL': 1,
            },
            'types': {
                'LIMIT': 1,
                'MARKET': 2,
                'STOP_LOSS': 3,
                'STOP_LOSS_LIMIT': 4,
                'TAKE_PROFIT': 5,
                'TAKE_PROFIT_LIMIT': 6,
                'LIMIT_MAKER': 7,
            },
            'fees': {
                'trading': {
                    'taker': 0.0022,  # 0.22% trading fee
                    'maker': 0.0022,  # 0.22% trading fee
                },
            },
        })

    def sign(self, path, api='open', method='GET', params={}, headers=None, body=None):
        if not (api in self.urls['api']):
            raise NotSupported(self.id + ' does not have a testnet/sandbox URL for ' + api + ' endpoints')
        url = self.urls['api'][api]
        url += '/' + path
        if api == 'signed':
            self.check_required_credentials()
            headers = {
                'X-MBX-APIKEY': self.apiKey,
            }
            recvWindow = self.safe_integer(self.options, 'recvWindow', 5000)
            query = None
            query = self.urlencode_with_array_repeat(self.extend({
                'timestamp': self.nonce(),
                'recvWindow': recvWindow,
            }, params))
            signature = self.hmac(self.encode(query), self.encode(self.secret))
            query += '&signature=' + signature
            url += '?' + query
        else:
            if method == 'GET':
                if params:
                    url += '?' + self.urlencode(params)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def fetch_time(self, params={}):
        method = 'openGetCommonTime'
        response = getattr(self, method)(params)
        return self.safe_integer(response, 'timestamp')

    def fetch_symbols(self, params={}):
        method = 'openGetCommonSymbols'
        response = getattr(self, method)(params)
        return response

    def fetch_order_book(self, symbol, limit=None, params={}):
        method = 'apiGetV3Depth'
        request = {
            'symbol': symbol.replace('_', ''),           # market[symbol]
        }
        if limit is not None:
            request['limit'] = limit
        response = getattr(self, method)(self.extend(request, params))
        return response                # map

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired('fetchOrders requires a symbol argument')
        method = 'signedGetOrders'
        request = {
            'symbol': symbol,          # market[symbol]
        }
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit
        response = getattr(self, method)(self.extend(request, params))
        return response                # map

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        requestSide = None
        requestType = None
        if side in self.sides:
            requestSide = self.sides[side]
        else:
            raise NotSupported('Side ' + side + ' not supported')
        if type in self.types:
            requestType = self.types[type]
        else:
            raise NotSupported('Type ' + type + ' not supported.')
        method = 'signedPostOrders'
        request = {
            'symbol': symbol,           # market[symbol]
            'side': requestSide,
            'type': requestType,
            'quantity': amount,
        }
        if price is not None:
            request['price'] = price
        response = getattr(self, method)(self.extend(request, params))
        return response

    def fetch_order(self, id, symbol=None, params={}):
        method = 'signedGetOrdersDetail'
        request = {
            'orderId': id,
        }
        response = getattr(self, method)(self.extend(request, params))
        return response

    def cancel_order(self, id, symbol=None, params={}):
        method = 'signedPostOrdersCancel'
        request = {
            'orderId': id,
        }
        response = getattr(self, method)(self.extend(request, params))
        return response                        # map

    def fetch_balance(self, params={}):
        method = 'signedGetAccountSpot'
        response = getattr(self, method)(params)
        return response

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        method = 'apiGetV3Trades'
        request = {
            'symbol': symbol.replace('_', ''),         # market[symbol]
        }
        if since is not None:
            request['fromId'] = since
        if limit is not None:
            request['limit'] = limit
        response = getattr(self, method)(self.extend(request, params))
        return response

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired('fetchOrders requires a symbol argument')
        method = 'signedGetOrdersTrades'
        request = {
            'symbol': symbol,                   # market[symbol]
        }
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit
        response = getattr(self, method)(self.extend(request, params))
        return response

    def fetch_l2_order_book(self, symbol, limit=None, params={}):
        method = 'apiGetV3aggTrades'
        request = {
            'symbol': symbol.replace('_', ''),         # market[symbol]
        }
        if limit is not None:
            request['limit'] = limit
        response = getattr(self, method)(self.extend(request, params))
        return response                # map
        #    "a": 26129,         # Aggregate tradeId
        #    "p": "0.01633102",  # Price
        #    "q": "4.70443515",  # Quantity
        #    "f": 27781,         # First tradeId
        #    "l": 27781,         # Last tradeId
        #    "T": 1498793709153,  # Timestamp
        #    "m": True,          # Was the buyer the maker?
        #    "M": True           # Was the trade the best price match?
