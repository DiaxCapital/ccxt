<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ArgumentsRequired;
use \ccxt\NotSupported;

class gooplex extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'gooplex',
            'name' => 'Gooplex',
            'countries' => array( 'BR' ), // US
            'certified' => false,
            'pro' => false,
            'urls' => array(
                'doc' => 'https://www.gooplex.com.br/apidocs/#api-document-description',
                'fees' => 'https://gooplex.zendesk.com/hc/pt/articles/360049326131-O-que-s%C3%A3o-taxas-de-negocia%C3%A7%C3%A3o-',
                'logo' => 'https://user-images.githubusercontent.com/228850/93481157-a0a2cb00-f8d4-11ea-8608-d56dd916a9ed.jpg',
                'referral' => 'https://www.gooplex.com.br/account/signup?ref=H8QQ57WT',
                'www' => 'https://www.gooplex.com.br',
                // API
                'api' => array(
                    'open' => 'https://www.gooplex.com.br/open/v1',
                    'signed' => 'https://www.gooplex.com.br/open/v1',
                    'api' => 'https://api.binance.com/api',
                ),
            ),
            'api' => array(
                'open' => array(               // public
                    'get' => array(
                        'common/time',
                        'common/symbols',
                    ),
                ),
                'signed' => array(             // private
                    'get' => array(
                        'orders',
                        'orders/detail',
                        'orders/trades',
                        'account/spot',
                    ),
                    'post' => array(
                        'orders',
                        'orders/cancel',
                    ),
                ),
                'api' => array(
                    'get' => array(
                        'v3/depth',
                        'v3/trades',
                        'v3/aggTrades',
                    ),
                ),
            ),
            'orderlimits' => array(
                5,
                10,
                20,
                50,
                100,
                500,
            ),
            'sides' => array(
                'BUY' => 0,
                'SELL' => 1,
            ),
            'types' => array(
                'LIMIT' => 1,
                'MARKET' => 2,
                'STOP_LOSS' => 3,
                'STOP_LOSS_LIMIT' => 4,
                'TAKE_PROFIT' => 5,
                'TAKE_PROFIT_LIMIT' => 6,
                'LIMIT_MAKER' => 7,
            ),
            'fees' => array(
                'trading' => array(
                    'taker' => 0.0022, // 0.22% trading fee
                    'maker' => 0.0022, // 0.22% trading fee
                ),
            ),
        ));
    }

    public function sign($path, $api = 'open', $method = 'GET', $params = array (), $headers = null, $body = null) {
        if (!(is_array($this->urls['api']) && array_key_exists($api, $this->urls['api']))) {
            throw new NotSupported($this->id . ' does not have a testnet/sandbox URL for ' . $api . ' endpoints');
        }
        $url = $this->urls['api'][$api];
        $url .= '/' . $path;
        if ($api === 'signed') {
            $this->check_required_credentials();
            $headers = array(
                'X-MBX-APIKEY' => $this->apiKey,
            );
            $recvWindow = $this->safe_integer($this->options, 'recvWindow', 5000);
            $query = null;
            $query = $this->urlencode_with_array_repeat(array_merge(array(
                'timestamp' => $this->nonce(),
                'recvWindow' => $recvWindow,
            ), $params));
            $signature = $this->hmac($this->encode($query), $this->encode($this->secret));
            $query .= '&$signature=' . $signature;
            $url .= '?' . $query;
        } else {
            if ($method === 'GET') {
                if ($params) {
                    $url .= '?' . $this->urlencode($params);
                }
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function fetch_time($params = array ()) {
        $method = 'openGetCommonTime';
        $response = $this->$method ($params);
        return $this->safe_integer($response, 'timestamp');
    }

    public function get_fees() {
        $feesKey = 'fees';
        $fees = $this->$feesKey;
        return $this->safe_value($fees, 'trading');
    }

    public function convert_symbol($market) {
        $trading_fees = $this->get_fees();
        $symbol = $this->safe_string($market, 'symbol');
        $id = str_replace('_', '/', $symbol);
        $id2 = str_replace('_', '', $symbol);
        $entry = array(
            'id' => $symbol,
            'symbol' => $id,
            'symbol2' => $id2,
            'base' => $this->safe_currency_code($market, 'baseAsset'),
            'quote' => $this->safe_currency_code($market, 'quoteAsset'),
            'active' => true,
            'taker' => $this->safe_float($trading_fees, 'taker'),
            'maker' => $this->safe_float($trading_fees, 'maker'),
            'percetage' => true,
            'tierBase' => false,
            'precision' => array(
                'price' => $this->safe_integer($market, 'quotePrecision'),
                'amount' => $this->safe_integer($market, 'basePrecision'),
                'cost' => $this->safe_integer($market, 'basePrecision'),
            ),
            'limits' => array(
                'amount' => array(
                    'min' => null,
                    'max' => null,
                ),
                'price' => array(
                    'min' => null,
                    'max' => null,
                ),
                'cost' => array(
                    'min' => null,
                    'max' => null,
                ),
            ),
            'info' => $market,
        );
        return $entry;
    }

    public function fetch_markets($params = array ()) {
        $method = 'openGetCommonSymbols';
        $response = $this->$method ($params);
        $data = $this->safe_value($response, 'data');
        $markets = $this->safe_value($data, 'list');
        $result = array();
        for ($i = 0; $i < count($markets); $i++) {
            $market = $markets[$i];
            $entry = $this->convert_symbol($market);
            $result[] = $entry;
        }
        return $result;
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        $method = 'apiGetV3Depth';
        $this->load_markets();
        $request = array(
            'symbol' => $this->markets[$symbol]['symbol2'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->$method (array_merge($request, $params));
        return $response;
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired('fetchOrders requires a $symbol argument');
        }
        $method = 'signedGetOrders';
        $this->load_markets();
        $request = array(
            'symbol' => $this->markets[$symbol]['id'],
        );
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->$method (array_merge($request, $params));
        return $response;
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $requestSide = null;
        $requestType = null;
        if (is_array($this->sides) && array_key_exists($side, $this->sides)) {
            $requestSide = $this->sides[$side];
        } else {
            throw new NotSupported('Side ' . $side . ' not supported');
        }
        if (is_array($this->types) && array_key_exists($type, $this->types)) {
            $requestType = $this->types[$type];
        } else {
            throw new NotSupported('Type ' . $type . ' not supported.');
        }
        $method = 'signedPostOrders';
        $this->load_markets();
        $request = array(
            'symbol' => $this->markets[$symbol]['id'],
            'side' => $requestSide,
            'type' => $requestType,
            'quantity' => $amount,
        );
        if ($price !== null) {
            $request['price'] = $price;
        }
        $response = $this->$method (array_merge($request, $params));
        return $response;
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        $method = 'signedGetOrdersDetail';
        $request = array(
            'orderId' => $id,
        );
        $response = $this->$method (array_merge($request, $params));
        return $response;
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        $method = 'signedPostOrdersCancel';
        $request = array(
            'orderId' => $id,
        );
        $response = $this->$method (array_merge($request, $params));
        return $response;
    }

    public function fetch_balance($params = array ()) {
        $method = 'signedGetAccountSpot';
        $response = $this->$method ($params);
        return $response;
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $method = 'apiGetV3Trades';
        $this->load_markets();
        $request = array(
            'symbol' => $this->markets[$symbol]['symbol2'],
        );
        if ($since !== null) {
            $request['fromId'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->$method (array_merge($request, $params));
        return $response;
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired('fetchOrders requires a $symbol argument');
        }
        $method = 'signedGetOrdersTrades';
        $this->load_markets();
        $request = array(
            'symbol' => $this->markets[$symbol]['id'],
        );
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->$method (array_merge($request, $params));
        return $response;
    }

    public function parse_l2($entry) {
        return array(
            'tradeId' => $this->safe_integer($entry, 'a'),
            'price' => $this->safe_float($entry, 'p'),
            'quantity' => $this->safe_float($entry, 'q'),
            'firstTradeId' => $this->safe_integer($entry, 'f'),
            'lastTradeId' => $this->safe_integer($entry, 'l'),
            'timestamp' => $this->safe_timestamp($entry, 'T'),
            'maker' => $this->safe_value($entry, 'm'),
            'bestPriceMatch' => $this->safe_value($entry, 'M'),
        );
    }

    public function fetch_l2_order_book($symbol, $limit = null, $params = array ()) {
        $method = 'apiGetV3AggTrades';
        $this->load_markets();
        $request = array(
            'symbol' => $this->markets[$symbol]['symbol2'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->$method (array_merge($request, $params));
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $result[] = $this->parse_l2($response[$i]);
        }
        return $result;
    }
}
